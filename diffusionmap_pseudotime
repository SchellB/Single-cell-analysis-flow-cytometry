###############################
### LOAD REQUIRED PACKAGES ####
###############################

## Please make sure, the latest versions of knn.covertree and destiny are installed (first load devtools). Those are not available through CRAN/Bioconductor
#install_github('flying-sheep/knn.covertree')
#install_github('theislab/destiny')

library(cytofast)
library(SingleCellExperiment)
library(dplyr)
library(ggplot2)
library(scales)
library(Seurat)
library(RColorBrewer)
library(reshape2)
library(devtools)
library(knn.covertree)
library(destiny)

################################
#### COMPUTE DIFFUSION MAP #####
################################

#NB: Either start directly with your exported cells of interest (using the result of CSV_to_FCS script), or continue working on data that already has been clustered: 
# For illustratory purposes we choose the latter.

## Import HSNE based clusters as generated in Cytosplore (www.cytosplore.org, right-click and save each cluster as fcs file)
# These fcs files contain the expression data of each individual cell with the cluster annotation
dirFCS = "path_to_your_folder_with_fcs_files"
allClusters <- readCytosploreFCS(dir = dirFCS, colNames = "description")

## Calculate diffusion map on selected parameters (adjust vars=c(....))
# reduce the K, if computational load is too high [it takes approximately 2 hours for the example dataset of 276266 cells]
dm <- DiffusionMap(allClusters$expr, vars = c("CD95_t", "CD8_t", "CD27_t", "CCR7_t", "CD45RA_t", "CD49b_t", "CD69_t", "CD103_t"), k=1000, suppress_dpt = TRUE, verbose=TRUE)

# Save diffusion map for later
setwd("path_to_your_folder_to_save_files")
saveRDS(dm, 'dm.rds')

#to load the dm file
dm <- readRDS("path_to_your_folder_to_save_files/dm.rds")

## Vizualize results:
# With the viz.dm function the first two components of the diffusion map can be visualized with the expression levels of a particular parameter applied as color scale
# Description of the input parameters
# dat: the diffusion map object
# param.name: the name of the parameter which you would like to plot as color scale
# if no limits are provided: for better visualization, the most extreme low and high percentile of the color values are normalized.
# if limits are provided: the color scale will be adjusted according to the provided limits (recommended for parameters which are expressed on all cells). To apply the same colorscale as in Cytosplore, provide the limits as set in Cytosplore.

viz.dm <- function(dat,param.name,limits=NULL){
  ColVal <- dataset(dat)[,param.name]
  if(is.null(limits)){
    Lim <- quantile(ColVal,probs=seq(0,1,0.01))[c(2,100)]
    p <- ggplot(dat, aes(x = DC1, y = DC2)) +geom_point(aes(color = ColVal), size=0.1)+theme_classic()+scale_color_distiller(name=param.name, palette = "RdYlBu", limits=Lim, oob=squish)+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor=element_blank())+ggtitle(param.name)
  } else {
    p <- ggplot(dat, aes(x = DC1, y = DC2)) +geom_point(aes(color = ColVal), size=0.1)+theme_classic()+scale_color_distiller(name=param.name, palette = "RdYlBu", limits=c(limits[1],limits[2]), oob=squish)+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor=element_blank())+ggtitle(param.name)
  }
  p
}

viz.dm(dat=dm,param.name="CD95_t")
viz.dm(dat=dm, param.name="CD3_t", limits=c(0,3.7))

#plot the clusters as color on the diffusion map
ggplot(dm, aes(x=DC1, y=DC2))+geom_point(aes(x=DC1, y=DC2, color=clusterID), size=0.1)+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor=element_blank())


############################
#### COMPUTE SLINGSHOT #####
############################

##Create a Slingshot object and add cell expression and cluster information to this object
#create slingshot object
slingshot_object <- SingleCellExperiment(assays = List(norm = as.matrix(t(allClusters$expr))))

#add expression data to slingshot and select markers to use for the pseudotime calculation
reducedDims(slingshot_object) <- SimpleList(expressiondata = as.matrix(allClusters$expr%>%select(c("CD95_t", "CD8_t", "CD27_t", "CCR7_t", "CD45RA_t", "CD49b_t", "CD69_t", "CD103_t"))))

#add clusters to slingshot object. Either the HSNE-based clusters, the Louvain clusters, or clusters generated by another method.
#In this example we demonstrate the use of the HSNE-based clusters as stored in allClusters$expr$clusterID
colData(slingshot_object)$clusters <- allClusters$expr$clusterID

#calculate lineages (optional: appoint starting cluster)
#In this example we appoint CD4-1, the naive T cells, as start cluster.
lin <- getLineages(reducedDims(slingshot_object)$expressiondata,colData(slingshot_object)$clusters, start.clus='CD4-1.fcs')

#construct smooth curves and calculate pseudotime [This will take approximately 12 hours for this example dataset]
#to reduce computational time, curves can be approximated by a fixed number of points, for instance 100.
curve <- getCurves(lin, approx_points=FALSE)

#save curves object for later
saveRDS(curve, 'curve.rds')

#to load the curve object
curve <- readRDS("path_to_your_folder_to_save_files/curve.rds")


############################
#### VISUALIZE RESULTS #####
############################

#generate table with diffusion map coordinates, pseudotimevalues and cluster assignment (either the HSNE-based clusters or other clusters)
#In this example we use the HSNE-based clusters
pseudotimevalues <- cbind(as.data.frame(slingPseudotime(curve)), DC1=dm$DC1, DC2=dm$DC2, clusterID=allClusters$expr$clusterID)

#reshape table 
pseudotimevalues <- melt(pseudotimevalues, id.vars=c('clusterID', 'DC1', 'DC2'), variable.name='lineage', value.name = 'pseudotime')
#rename curve to lineage
pseudotimevalues$lineage <- gsub('curve', 'lineage', pseudotimevalues$lineage)

#exclude cells with NA pseudotimevalues (those cells are not present in all lineages and have NA values for the lineages in which they are absent)
pseudotimevaluesexclNA <- pseudotimevalues%>%filter(pseudotime!='NA')

#generate colorpalette
colors <- colorRampPalette(rev(brewer.pal(11, 'Spectral'))[-6])(100)

#ggplots of each lineage colored by either pseudotime or by cluster
ggplot(pseudotimevaluesexclNA, aes(x=DC1, y=DC2))+geom_point(aes(x=DC1, y=DC2, color=pseudotime),size=0.1, alpha=0.3) +facet_wrap(~lineage)+scale_color_gradientn(colours=colors)+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor=element_blank())
ggplot(pseudotimevaluesexclNA, aes(x=DC1, y=DC2))+geom_point(aes(x=DC1, y=DC2, color=clusterID),size =0.1)+facet_wrap(~lineage)+theme_bw()+scale_color_brewer(palette="Dark2", direction=-1)


#jitterplot of pseudotimevalues per lineage
ggplot(pseudotimevaluesexclNA, aes(x=pseudotime, y=lineage)) + geom_jitter(aes(x=pseudotime, y=lineage, color=clusterID), size=0.1)+scale_color_brewer(palette="Dark2", direction=-1)+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor=element_blank())


###################################
#### COMPUTE LOUVAIN CLUSTERS #####
###################################

## As an alternative for the HSNE-based clusters, Louvain clusters can be used as input for the Slingshot
# Use expression data of the allClusters file to compute Louvain clusters, or import the cells of interest as fcs (use CSV_to_FCS script)
# In this example we use the expression data of the allClusters file

##The louvain clustering as implemented in the Seurat package (developed for analysis of single-cell RNA sequencing data) is used
#generate seurat object and select parameters for Louvain cluster calculation
seurat_df <- as.data.frame(t(allClusters$expr%>%select(c("CD95_t", "CD8_t", "CD27_t", "CCR7_t", "CD45RA_t", "CD49b_t", "CD69_t", "CD103_t"))))

#seurat requires a key plus a digit representing a dimension number as rownames
rownames(seurat_df) = paste0("parameter-", 1:nrow(seurat_df))
seurat_object <- CreateSeuratObject(seurat_df)
seurat_object[["parameter"]] <- CreateDimReducObject(embedding = as.matrix(t(seurat_df)), key ="parameter_")

#First, the KNN-graph is constructed via the FindNeighbors function
#reduce k if computational load is too high
seurat_object <- FindNeighbors(object = seurat_object, dims = 1:nrow(seurat_df), verbose = FALSE, k.param=1000, do.plot=FALSE, reduction = 'parameter')

#Second, to cluster the cells, the Louvain algorithm is applied
#The resolution parameter sets the ‘granularity’ of the downstream clustering, the higher the resolution, the higher the number of clusters.
#If there are too many clusters, artificial lineages will be identifed by Slingshot. If no clusters are provided, only 1 curve will be fitted.
seurat_object <- FindClusters(seurat_object,resolution =0.25)

#visualize clusters on diffusion map
clusterlouvain <- seurat_object@meta.data$RNA_snn_res.0.25
ggplot(dm, aes(x=DC1, y=DC2))+geom_point(aes(x=DC1, y=DC2, color=clusterlouvain), size=0.1)+theme_bw()+theme(panel.grid.major = element_blank(), panel.grid.minor=element_blank())

#save Seurat object for later
saveRDS(seurat_object, 'seurat_object.rds')

#load Seurat object
seurat_object <- readRDS("path_to_your_folder_to_save_files/seurat_object.rds")


###To furter calculate slingshot and visualize results replace the HSNE-based clusters (allClusters$expr$clusterID) in the script by the Louvain clusters (clusterlouvain)







